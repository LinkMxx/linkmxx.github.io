<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Origin</title>
  
  
  <link href="https://theme-next.js.org/atom.xml" rel="self"/>
  
  <link href="https://theme-next.js.org/"/>
  <updated>2022-04-22T10:16:03.943Z</updated>
  <id>https://theme-next.js.org/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS冷知识</title>
    <link href="https://theme-next.js.org/JS%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    <id>https://theme-next.js.org/JS%E5%86%B7%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-22T17:48:30.000Z</published>
    <updated>2022-04-22T10:16:03.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS冷知识"><a href="#JS冷知识" class="headerlink" title="JS冷知识"></a>JS冷知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>(!(<del>+[])+{})[--[</del>+&quot;&quot;][+[]]<em>[<del>+[]]+~~!+[]]+({}+[])[[</del>!+[]]</em>~+[]]<br>大家可以试着运行一下这串代码</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20200908195554203.png#pic_center" loading="lazy"></p><p>是不是输出的&quot;sb&quot;让人眼前一惊</p><p><img src="https://img-blog.csdnimg.cn/20200908195609530.jpg#pic_center" loading="lazy"></p><p>肯定都会去想这个变相的骂人是怎么实现的</p><h2 id="原始式子拆分"><a href="#原始式子拆分" class="headerlink" title="原始式子拆分"></a>原始式子拆分</h2><p>解这种题目，当然要把他们先按<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQkYlOTAlRTclQUUlOTclRTclQUMlQTYmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">运算符<i class="fa fa-external-link-alt"></i></span>给拆分开来，一步一步分析了</p><p><img src="https://img-blog.csdnimg.cn/20200908195627731.png#pic_center" loading="lazy"></p><p>首先可以将原始的式子分为</p><ul><li>式子1 (!(<del>+[])+{})[–[</del>+&quot;&quot;][+[]]<em>[~+[]]+~~!+[]]<br /></em></li><li><em>式子2 ({}+[])[[~!+[]]</em>~+[]]</li></ul><p>并且式子1和式子2通过 “+” 运算符连接</p><h3 id="拆分式子1-–-quot-quot"><a href="#拆分式子1-–-quot-quot" class="headerlink" title="拆分式子1 (!(+[])+{})[–[+&quot;&quot;][+[]]*[~+[]]+~~!+[]]"></a>拆分式子1 (!(<del>+[])+{})[–[</del>+&quot;&quot;][+[]]*[~+[]]+~~!+[]]</h3><p>式子1又可以分为</p><ul><li>式子3: (!(~+[])+{})</li><li>式子4: --[[<del>+&quot;&quot;][+[]]]*[</del>+[]]+~~!+[]</li></ul><p>并且式子3和式子4通过 “[]” 连接</p><p>式子3又可以分为</p><ul><li><p>式子5: (!(~+[]))</p></li><li><p>式子6: {}</p></li></ul><p>并且式子5和式子6用 “+” 运算符连接</p><h3 id="式子5-结果"><a href="#式子5-结果" class="headerlink" title="式子5 (!(~+[])) 结果"></a>式子5 (!(~+[])) 结果</h3><p>先来看式子5 (!(~+[]))</p><p>优先级为先执行+，然后执行~</p><p>所以+[] 一元+，触发toNumber，而[]的toNumber为0</p><p>所以现在变成了!(<del>0)，而</del>是一元位运算 触发toInt32 所以 ~0为 -1</p><blockquote><p>所以式子5为false</p></blockquote><h3 id="式子3-结果"><a href="#式子3-结果" class="headerlink" title="式子3 (!(~+[])+{}) 结果"></a>式子3 (!(~+[])+{}) 结果</h3><p>式子3是式子5和式子6通过+链接 所以就是 false + {}</p><p>这是二元+，所以会对左右两边的值进行hint为空的也就是number时的toPrimitive，先执行valueOf，false的valueOf为false，为基本类型值直接返回，而{}经过valueOf后返回{}，不为基本类型值，所以继续执行toString，{}.toString为&quot;[object Object]&quot;</p><p>执行完toPrimitive后，判断两边值是否有string类型，而这里的&quot;[object Object]&quot;是string类型，所以执行拼接操作</p><blockquote><p>所以式子3为 “false[object Object]”</p></blockquote><h3 id="拆分式子4-quot-quot"><a href="#拆分式子4-quot-quot" class="headerlink" title="拆分式子4 --[[+&quot;&quot;][+[]]]*[+[]]+~~!+[]"></a>拆分式子4 --[[<del>+&quot;&quot;][+[]]]*[</del>+[]]+~~!+[]</h3><p>式子4可以分为</p><ul><li>式子7 --[[<del>+&quot;&quot;][+[]]]*[</del>+[]]</li><li>式子8 ~~!+[]</li></ul><p>并且式子7和式子8通过 “+” 运算符连接</p><h3 id="拆分式子7-quot-quot"><a href="#拆分式子7-quot-quot" class="headerlink" title="拆分式子7 --[[+&quot;&quot;][+[]]]*[+[]]"></a>拆分式子7 --[[<del>+&quot;&quot;][+[]]]*[</del>+[]]</h3><p>式子7又可分为</p><ul><li>式子9 --[[~+&quot;&quot;][+[]]]</li><li>式子10 [~+[]]</li></ul><p>并且式子9和式子10通过 “*” 运算符连接</p><h3 id="拆分式子9-quot-quot"><a href="#拆分式子9-quot-quot" class="headerlink" title="拆分式子9 --[[~+&quot;&quot;][+[]]]"></a>拆分式子9 --[[~+&quot;&quot;][+[]]]</h3><p>式子9又可分为操作符–与</p><ul><li>式子11 [~+&quot;&quot;]</li><li>式子12 +[]</li></ul><p>并且式子11和式子12通过 “[]” 连接</p><h3 id="式子11-quot-quot-结果"><a href="#式子11-quot-quot-结果" class="headerlink" title="式子11[~+&quot;&quot;] 结果"></a>式子11[~+&quot;&quot;] 结果</h3><p>接下来分析式子11 [~+&quot;&quot;]</p><p>同样先执行+，一元+会触发toNumber，&quot;&quot;.toNumber为0，</p><p>所以此时为0，前面也说了0为-1</p><blockquote><p>因此式子11为[-1]</p></blockquote><h3 id="式子12-结果"><a href="#式子12-结果" class="headerlink" title="式子12 +[] 结果"></a>式子12 +[] 结果</h3><p>式子12 +[]</p><p>触发toNumber [].toNumber为 0</p><blockquote><p>因此式子12为0</p></blockquote><h3 id="式子9-quot-quot-结果"><a href="#式子9-quot-quot-结果" class="headerlink" title="式子9 --[[~+&quot;&quot;][+[]]] 结果"></a>式子9 --[[~+&quot;&quot;][+[]]] 结果</h3><p>而式子11和式子12通过[]连接，又有–操作符在前</p><p>所以式子9为–[-1][0]，这里[-1][0]取得就是-1这个数了，数组的取值而已，没多大问题，然后执行–</p><blockquote><p>此时式子9为 -2</p></blockquote><h3 id="式子10-结果"><a href="#式子10-结果" class="headerlink" title="式子10 [~+[]] 结果"></a>式子10 [~+[]] 结果</h3><p>然后分析式子10 [~+[]]</p><p>同理，先+[] ，触发toNumber，为0 ，</p><p>[~0]为[-1]，</p><blockquote><p>所以式子10为[-1]</p></blockquote><h3 id="式子7-quot-quot-结果"><a href="#式子7-quot-quot-结果" class="headerlink" title="式子7 --[[+&quot;&quot;][+[]]]*[+[]] 结果"></a>式子7 --[[<del>+&quot;&quot;][+[]]]*[</del>+[]] 结果</h3><p>式子7是式子9和式子10通过*连接的</p><p>所以式子7为 -2 * [-1]</p><p>而二元*运算符，会将左右两边值都进行toNumber，-2的toNumber为-2，[-1]的toNumber，会触发toPrimitive</p><p>先执行valueOf，返回的数组本身，不是基本类型值，因此执行toString，所以为&quot;-1&quot;，为&quot;-1&quot;继续执行toNumber，所以为-1，</p><blockquote><p>因此式子7为-2 * -1，式子7为2</p></blockquote><h3 id="式子8-结果"><a href="#式子8-结果" class="headerlink" title="式子8 ~~!+[] 结果"></a>式子8 ~~!+[] 结果</h3><p>此时分析式子8 ~~!+[]</p><p>先执行+ ，触发toNumber，为0。</p><p>然后执行!0，0执行toBoolean，0变成false，所以!false为true</p><p>然后执行<del>true。 true执行toInt32，为1，所以</del>1为-2 ，</p><p>然后执行~-2，为1</p><blockquote><p>所以式子8为1</p></blockquote><h3 id="式子4-quot-quot-结果"><a href="#式子4-quot-quot-结果" class="headerlink" title="式子4 --[[+&quot;&quot;][+[]]]*[+[]]+~~!+[] 结果"></a>式子4 --[[<del>+&quot;&quot;][+[]]]*[</del>+[]]+~~!+[] 结果</h3><p>而式子4是式子7和式子8通过+连接的</p><blockquote><p>所以式子4为 2 + 1，式子4为3</p></blockquote><h2 id="式子1-结果"><a href="#式子1-结果" class="headerlink" title="式子1 结果"></a>式子1 结果</h2><p>式子1是式子3和式子4通过[]连接的</p><p>所以式子1 为 “false[object Object]”[3]</p><blockquote><p>所以式子1为下标为3的元素，也就是&quot;s&quot;</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908195805504.jpg#pic_center" loading="lazy"></p><h2 id="拆分式子2"><a href="#拆分式子2" class="headerlink" title="拆分式子2 ({}+[])[[!+[]]*+[]]"></a>拆分式子2 ({}+[])[[<del>!+[]]*</del>+[]]</h2><p>现在分析式子2 ({}+[])[[<del>!+[]]*</del>+[]]</p><p>式子2可分为</p><ul><li>式子13 ({} + [])</li><li>式子14 [<del>!+[]]*</del>+[]</li></ul><p>并且式子13和式子14通过 “[]” 连接</p><h3 id="拆分式子14"><a href="#拆分式子14" class="headerlink" title="拆分式子14 [!+[]]*+[]"></a>拆分式子14 [<del>!+[]]*</del>+[]</h3><p>式子14可分为</p><ul><li>式子15 [~!+[]]</li><li>式子16 ~+[] ，</li></ul><p>并且式子15和式子16通过 “*” 运算符连接</p><h3 id="式子13-结果"><a href="#式子13-结果" class="headerlink" title="式子13 ({} + []) 结果"></a>式子13 ({} + []) 结果</h3><p>现在分析式子13 ({} + [])</p><p>这是很经典的，前面也分析过，双元+，会对左右两边的值进行toPrimitive</p><p>hint值为空，所以执行hint为Number的[[DefaultValue]]，所以先执行valueOf，而{} 和[]的valueOf都是返回本身，也都不是基本类型值</p><p>因此会继续执行toString，而{} 的toString为&quot;[object Object]&quot;，而[]的toString为&quot;&quot;，因此再判断左右两边值是否有string类型，两边都是string类型，所以进行拼接操作</p><p>所以 “[object Object]” + “”</p><blockquote><p>所以式子13为&quot;[object Object]&quot;</p></blockquote><h3 id="式子15-结果"><a href="#式子15-结果" class="headerlink" title="式子15 [~!+[]] 结果"></a>式子15 [~!+[]] 结果</h3><p>现在分析式子15 [~!+[]]</p><p>同理，先执行+[]，触发toNumber，[]的toNumber为0</p><p>执行!0，0先toBoolean为false，然后!false为true</p><p>然后~true，true先toInt32为1</p><p>然后~1为-2</p><blockquote><p>所以式子15为[-2]</p></blockquote><h3 id="式子16-结果"><a href="#式子16-结果" class="headerlink" title="式子16 ~+[] 结果"></a>式子16 ~+[] 结果</h3><p>现在分析式子16 ~+[]</p><p>同理 先执行+[]，为0，</p><p>然后~0</p><blockquote><p>所以式子16为-1</p></blockquote><h3 id="式子14-结果"><a href="#式子14-结果" class="headerlink" title="式子14 [!+[]]*+[] 结果*"></a>式子14 [<del>!+[]]*</del>+[] 结果*</h3><p><em>式子14是式子15和式子16通过</em>连接</p><p>所以式子14为 [-2] * -1 ，而双元* ，会对左右两边的进行toNumber</p><p>[-2]的toNumber首先会触发toPrimtive，首先valueOf返回[-2]，不是基本类型值，继续执行toString，为&quot;-2&quot;，&quot;-2&quot;再执行toNumber，为-2</p><p>而-1的toNumber当然就是-1</p><blockquote><p>所以式子14为-2 * -1，所以式子14为2</p></blockquote><h2 id="式子2-结果"><a href="#式子2-结果" class="headerlink" title="式子2 结果"></a>式子2 结果</h2><p>式子2是式子13和式子14通过[]连接</p><p>因此式子4为&quot;[object Object]&quot;[2]</p><blockquote><p>因此式子2也就是索引为2的元素:“b”</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908195830683.jpg#pic_center" loading="lazy"></p><h3 id="最初的式子的结果"><a href="#最初的式子的结果" class="headerlink" title="最初的式子的结果"></a>最初的式子的结果</h3><p>最初的式子是式子1和式子2通过+连接的</p><p>所以最初的式子为 “s” + “b”，双元+运算符</p><p>对两边值进行toPrimitive，首先执行valueOf，返回本身，且为基本类型值，所以返回&quot;s&quot;与&quot;b&quot;</p><p>执行完toPrimitive后，判断左右两边值是否有string类型，两边都为string类型，所以执行拼接操作</p><blockquote><p>所以&quot;s&quot; + “b”，最初的式子为&quot;sb&quot;，也是挺有趣的一句话鸭</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908195839206.jpg#pic_center" loading="lazy"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这算是一道考验对<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTclQjElQkIlRTUlOUUlOEIlRTglQkQlQUMlRTYlOEQlQTImc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">类型转换<i class="fa fa-external-link-alt"></i></span>规范的题目，而且考的比较详细了，如果能够正确分析出来，可以说是类型转换掌握的差不多了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JS冷知识&quot;&gt;&lt;a href=&quot;#JS冷知识&quot; class=&quot;headerlink&quot; title=&quot;JS冷知识&quot;&gt;&lt;/a&gt;JS冷知识&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;(!(&lt;del&gt;+[])+{})[--[&lt;/del&gt;+&amp;quot;&amp;quot;][+[]]&lt;em&gt;[&lt;del&gt;+[]]+~~!+[]]+({}+[])[[&lt;/del&gt;!+[]]&lt;/em&gt;~+[]]&lt;br&gt;大家可以试着运行一下这串代码&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
